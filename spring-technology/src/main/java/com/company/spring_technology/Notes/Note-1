Question -1 : Try-with-resource bloku nə üçün istifadə olunur?
   Custom class-ı nə zaman bu blokda istifadə edə bilərik?

   Bu blok açılan resursun avtomatik bağlanmasını təmin edir.
   Adətən file və db-ilə istifadə olunur.

   try (ResursClass myResurs = new ResursClass()) {
       // ResursClass obyektindən istifadə edilir
   } catch (Exception e) {
       e.printStackTrace();
   }

   Burada myResurs resursu istifadə olunacaq və try-catch bloku sonlandıqda avtomatik bağlanacaq.

   Custom class-ın bu kod blokunda istifadə oluna bilməsi üçün o AutoCloseable interface-dən implement olmalıdır.
   Ümumiyyətlə bu kod blokunda ancaq AutoCloseable interface-dən implement edən resurslar istifadə oluna bilər.
   Bu interface-in daxilində olan close() metodu açılan resursun avtomatik bağlanmasını təmin edir.

Question -2: N+1 problemi nə zaman yaranır və həlli necədir?

      N+1 problemi Hibernate və digər ORM-lərdə yaranan performans problemidir.
      SQL-də bir-birilə əlaqəli olan (One-to-Many və ya Many-to-One) cədvəllərdə
      əsas obyektə sorğu verən zaman əlaqəli obyekt üçün də artıq sorğuların göndərilməsi zamanı yaranan problemdir.
      Məsələn: Employee və Profession cədvəllərimiz var (Many-to-One). Bilirik ki, 1 işçinin 1 ixtisası ola bilər,
      1 ixtisasa sahib isə çoxlu sayda işçi ola bilər. Biz Profession obyektinə sorğu göndərsiyimiz halda belə bir senari baş verir:
         1) Select * from Profession
            Bu zaman fərz edəkki cədvəldə 5 sətir məlumat var. İlk sətir məlumatı əldə etdikdən sonra (fərz edək ki, bu profesiion-un Id=1 dir)
            Hibernate arxa planda bu cədvəlin əlaqəli olduğu Employee cədvəlinə də sorğu göndərir. Əgər professionId=1 olan 3 işçi varsa, bu zaman:

            Select * from Employee where professionId=1
            Select * from Employee where professionId=1
            Select * from Employee where professionId=1

            Arxa planda bu sorğu 3 dəfə gedir yuxarda qeyd olunduğu üçün.
            Deməli N sayda employee -ilə əlaqəli olan 1 profession üçün sorğu N+1 sayda gedəcək (N dəfə employee üçün 1 dəfə profession üçün)

            İkinci sətirdəki profession-u götürdükdə (fərz edək ki, bu profesiion-un Id=2 dir) eyni senari təkrarlanacaq.Yəni:
            Əgər professionId=1 olan 2 işçi varsa, bu zaman:

             Select * from Employee where professionId=2
             Select * from Employee where professionId=2

             Gördüyümüz kimi biz profession cədvəlinə sorğu göndərdiyimiz halda bu arxa planda əlaqəli obyektlə bağlı artıq sorğular generasiya olunur
             və bu da böyük db-lərlə işləyən zaman ciddi performans itgisinə səbəb olur.

             N+1 probleminin həlli üçün:
             1) Native query yazib join sorğusundan istifadə edə bilərik
             2) Fetch join istifadə edə bilərik
             3) EntityGraph istifadə edə bilərik.

Question -3:  Fetch join nədir?
      Əlaqəli entity ilə əsas entity-nin tək sorğuda gətirilməsini təmin edərək N+1 problemini həll edir.
      Department entity-i:
      @Entity
      public class Department {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          private String name;

          @OneToMany(mappedBy = "department")
          private List<Employee> employees;
      }

      Employee entity-i :
      @Entity
      public class Employee {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          private String name;

          @ManyToOne
          @JoinColumn(name = "department_id")
          private Department department;
      }

       fetch join sorğusu :
       String jpql = "SELECT d FROM Department d JOIN FETCH d.employees";
       List<Department> departments = entityManager.createQuery(jpql, Department.class).getResultList();

       Qeyd : Native query-mi daha optimaldır yoxsa fetch join-mi?
              Native query yazaraq biz sorğumuzu daha optimal hala gətirə bilərik ama ORM üstünlüklərindən istifadə edə bilməyəcəyik (cache-ləmə, lazy loading və s.).
              Eyni zamanda gələcəkdə DB-in daşınması kimi bir problem olduqda bu sorğular yeni dilə uyğun olaraq dəyişdirilməli ola bilər.

Question -4. EntityGraph nədir?
       Hibernate-də entity-lər arası əlaqələr lazy və ya eager olaraq təyin edilə bilər:

       a)Lazy loading: Əlaqəli entity-lər yalnız onlara ehtiyac olduğu zaman (ilk dəfə müraciət edildikdə) yüklənir.
       b)Eager loading: Əlaqəli entity-lər əsas entity ilə birlikdə dərhal yüklənir.

       EntityGraph bu davranışı dəyişdirmək üçün istifadə edilir. Siz, lazım gəldikdə, əsas entity ilə birlikdə yalnız müəyyən əlaqəli entity-ləri tək sorğu ilə yükləyə bilərsiniz.

       User və role entity-leri uzerinden getsek Əlaqələrin təyin olunması zaman fetchtype bilirikki default olaraq lazy olaraq gəlir.
       Bu da o deməkdir ki, əlaqəli obyektə sorğu yalnız ehtiyac olduğu halda göndəriləcək. Fərz edək ki, User entity-ne 5 müxtəlif yerdə sorğu göndərilib hansı ki
       bunlardan 2-də User-lə yanaşı Role-lara da ehtiyac var. Biz entity class-in özündə fetch-type-i dəyişib eager etsək, bu 5 sorğunun hər birində user cədvəli ilə
       yanaşı role cədvəlinə də sorğu gedəcək, ki, bu da performans problemlərinə (N+1) səbəb olduğu üçün bizə sərf etmir. Ona görə də biz burada entity graph-dan istifadə edərək
       hansı sorğu da ki User-lə birlikdə də Role-a ehtiyac varsa bu zaman hər iki cədvələ sorğu getməsini təmin edirik.

       Nümunə :
       EntityGraph<User> entityGraph = entityManager.createEntityGraph(User.class);
       entityGraph.addAttributeNodes("roles");

       Map<String, Object> properties = new HashMap<>();
       properties.put("javax.persistence.loadgraph", entityGraph);

       User user = entityManager.find(User.class, userId, properties);

       loadGraph-Lazy
       fetchgraph-Eager

Question -5. Pessimistic vs Optimistic locking
            Optimistic və Pessimistic Locking Hibernate və JPA-də concurrency (eyni vaxtda birdən çox istifadəçinin məlumatlarla işləməsi) məsələlərini həll etmək üçün istifadə olunan iki fərqli yanaşmadır.
    1) Pessimistic locking ---> üzərində əməliyyat gedən entity locklanır ki, başqa bir user onun üzərində əməliyyat apara bilməsin.
                                BU prosses session səviyyəsində aparılır və transaction başlarkən açılan session sonlanana qədər və ya rolback
                                edilənə qədər row lock vəziyyətində qalır.(Qeyd: DeadLock-a səbəb ola bilər)
                                Hibernate-də Pessimistic Locking növlərini LockModeType vasitəsilə təyin edə bilərsiniz.
                                Hibernate-də əsas 3 növ Pessimistic Locking mövcuddur:
                                a) PESSIMISTIC_READ : locklanan row üzərində ancaq read əməliyyatı aparmaq mümkündür. Write əməliyyatına icazə verilmir.
                                b) PESSIMISTIC_WRITE : locklanan  row üzərində nə read, nə də write əməliyyatını aparmağa icazə verilmir.
                                                        Employee employee = entityManager.find(Employee.class, id, LockModeType.PESSIMISTIC_WRITE);
                                c) PESSIMISTIC_FORCE_INCREMENT : PESSIMISTIC_WRITE ilə eynidir, ondan fərqi ondadır ki, versiyalama prinsipi ilə işləyir.
                                                                 Row-a lock tədbiq edildikdə, həmin row üzərində dəyişiklik aparılmasa belə versiya nömrəsi artırılır.
                                                                 entityManager
                                                                     .lock(entity, LockModeType.PESSIMISTIC_FORCE_INCREMENT);

       Pessimistic lock Stock Management, Bank operations, Rental Services kimi case-lərdə tədbiq oluna bilər.
        I. Online alış-veriş saytında müştərilər eyni zamanda bir məhsulu sifariş edə bilərlər. Əgər bu məhsulun yalnız 1 ədəd qalığı varsa və iki müştəri eyni anda
           bu məhsulu sifariş etməyə çalışarsa, məhsul iki dəfə satıla bilər ki, bu da problemlər yarada bilər.
       -- Birinci müştəri məhsulu sifariş etmək istədikdə məhsulun stok məlumatı kilidlənir və başqa bir müştəri stok məlumatına müraciət edə bilmir.
       -- Əgər birinci müştəri məhsulu uğurla sifariş edərsə, stok yenilənir və kilid açılır.
       -- Sonra ikinci müştəri həmin məhsula müraciət etdikdə, artıq stokda mövcud olmadığını görür.

       II. Avtomobil icarəsi sistemində eyni avtomobili birdən çox istifadəçi eyni vaxtda rezerv etməyə çalışa bilər. Əgər bir avtomobil eyni anda bir neçə şəxsə icarəyə verilərsə,
           bu konflikt və narazılıq yarada bilər.
       -- İcarə sistemində, bir avtomobilin icarə üçün mövcudluğunu yoxlayarkən, həmin avtomobil kilidlənir.
       -- Avtomobilə həmin anda başqa bir şəxs müraciət etdikdə, onun kilidli olduğunu görür və mövcud olmadığını anlayır.
       -- İlk şəxs icarə prosesini tamamladıqdan sonra kilid açılır və başqa istifadəçilər bu avtomobili icarəyə götürə bilərlər.


       QEYD : pessimistic locking performansa mənfi təsir edə bilər, çünki obyektlər kilidləndikdə digər tranzaksiyalar gözləməli olur. Bu səbəbdən, bu metod yalnız ciddi məlumat təhlükəsizliyi və tamlığı tələb edən hallarda tətbiq olunmalıdır.

    2) Optimistic locking ---> bir row üzərində eyni anda birdən çox əməliyyatın gedə bildiyini göstərir və prosses zamanı heç bir lock-lama tədbiq olunmur.
                               Optimistic locking versiyalama prinspindən istifadə edir.
      @Version --> entity class-ında versiyalanma üçün yaradılan field-in üzərinə qoyulur. Adətən tam ədəd tipi və ya Date tipləri ilə istifadə olunur.
               -- Hibernate row-u çəkib oxuyarkən versiyanı da oxuyur və yadında saxlayır.
               -- Row üzərində dəyişiklik baş verən zaman, hibernate row-un versiya nömrəsini yenidən yoxlayır. Əgər bu zaman hibernate-in yaddaşda saxladığı
                  nömrə ilə bu nömrə uyğun gəlməzsə bu zaman conflict yaranır və OptimisticLockExaption atılır. Yox əgər hər iki versiya nömrəsi bir-birinə
                  eyni olarsa bu zaman əməliyyat uğurla aparılır və versiya nömrəsi 1 vahid artırılır.





Question -. @Transaction nə üçün istifadə olunur?
