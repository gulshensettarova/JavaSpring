Question -1 : Try-with-resource bloku nə üçün istifadə olunur?
   Custom class-ı nə zaman bu blokda istifadə edə bilərik?

   Bu blok açılan resursun avtomatik bağlanmasını təmin edir.
   Adətən file və db-ilə istifadə olunur.

   try (ResursClass myResurs = new ResursClass()) {
       // ResursClass obyektindən istifadə edilir
   } catch (Exception e) {
       e.printStackTrace();
   }

   Burada myResurs resursu istifadə olunacaq və try-catch bloku sonlandıqda avtomatik bağlanacaq.

   Custom class-ın bu kod blokunda istifadə oluna bilməsi üçün o AutoCloseable interface-dən implement olmalıdır.
   Ümumiyyətlə bu kod blokunda ancaq AutoCloseable interface-dən implement edən resurslar istifadə oluna bilər.
   Bu interface-in daxilində olan close() metodu açılan resursun avtomatik bağlanmasını təmin edir.

Question -2: N+1 problemi nə zaman yaranır və həlli necədir?

      N+1 problemi Hibernate və digər ORM-lərdə yaranan performans problemidir.
      SQL-də bir-birilə əlaqəli olan (One-to-Many və ya Many-to-One) cədvəllərdə
      əsas obyektə sorğu verən zaman əlaqəli obyekt üçün də artıq sorğuların göndərilməsi zamanı yaranan problemdir.
      Məsələn: Employee və Profession cədvəllərimiz var (Many-to-One). Bilirik ki, 1 işçinin 1 ixtisası ola bilər,
      1 ixtisasa sahib isə çoxlu sayda işçi ola bilər. Biz Profession obyektinə sorğu göndərsiyimiz halda belə bir senari baş verir:
         1) Select * from Profession
            Bu zaman fərz edəkki cədvəldə 5 sətir məlumat var. İlk sətir məlumatı əldə etdikdən sonra (fərz edək ki, bu profesiion-un Id=1 dir)
            Hibernate arxa planda bu cədvəlin əlaqəli olduğu Employee cədvəlinə də sorğu göndərir. Əgər professionId=1 olan 3 işçi varsa, bu zaman:

            Select * from Employee where professionId=1
            Select * from Employee where professionId=1
            Select * from Employee where professionId=1

            Arxa planda bu sorğu 3 dəfə gedir yuxarda qeyd olunduğu üçün.
            Deməli N sayda employee -ilə əlaqəli olan 1 profession üçün sorğu N+1 sayda gedəcək (N dəfə employee üçün 1 dəfə profession üçün)

            İkinci sətirdəki profession-u götürdükdə (fərz edək ki, bu profesiion-un Id=2 dir) eyni senari təkrarlanacaq.Yəni:
            Əgər professionId=1 olan 2 işçi varsa, bu zaman:

             Select * from Employee where professionId=2
             Select * from Employee where professionId=2

             Gördüyümüz kimi biz profession cədvəlinə sorğu göndərdiyimiz halda bu arxa planda əlaqəli obyektlə bağlı artıq sorğular generasiya olunur
             və bu da böyük db-lərlə işləyən zaman ciddi performans itgisinə səbəb olur.

             N+1 probleminin həlli üçün:
             1) Native query yazib join sorğusundan istifadə edə bilərik
             2) Fetch join istifadə edə bilərik
             3) EntityGraph istifadə edə bilərik.

Question -3:  Fetch join nədir?
      Əlaqəli entity ilə əsas entity-nin tək sorğuda gətirilməsini təmin edərək N+1 problemini həll edir.
      Department entity-i:
      @Entity
      public class Department {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          private String name;

          @OneToMany(mappedBy = "department")
          private List<Employee> employees;
      }

      Employee entity-i :
      @Entity
      public class Employee {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          private String name;

          @ManyToOne
          @JoinColumn(name = "department_id")
          private Department department;
      }

       fetch join sorğusu :
       String jpql = "SELECT d FROM Department d JOIN FETCH d.employees";
       List<Department> departments = entityManager.createQuery(jpql, Department.class).getResultList();

       Qeyd : Native query-mi daha optimaldır yoxsa fetch join-mi?
              Native query yazaraq biz sorğumuzu daha optimal hala gətirə bilərik ama ORM üstünlüklərindən istifadə edə bilməyəcəyik (cache-ləmə, lazy loading və s.).
              Eyni zamanda gələcəkdə DB-in daşınması kimi bir problem olduqda bu sorğular yeni dilə uyğun olaraq dəyişdirilməli ola bilər.

Question -4. EntityGraph nədir?
       Hibernate-də entity-lər arası əlaqələr lazy və ya eager olaraq təyin edilə bilər:

       a)Lazy loading: Əlaqəli entity-lər yalnız onlara ehtiyac olduğu zaman (ilk dəfə müraciət edildikdə) yüklənir.
       b)Eager loading: Əlaqəli entity-lər əsas entity ilə birlikdə dərhal yüklənir.

       EntityGraph bu davranışı dəyişdirmək üçün istifadə edilir. Siz, lazım gəldikdə, əsas entity ilə birlikdə yalnız müəyyən əlaqəli entity-ləri tək sorğu ilə yükləyə bilərsiniz.

       User və role entity-leri uzerinden getsek Əlaqələrin təyin olunması zaman fetchtype bilirikki default olaraq lazy olaraq gəlir.
       Bu da o deməkdir ki, əlaqəli obyektə sorğu yalnız ehtiyac olduğu halda göndəriləcək. Fərz edək ki, User entity-ne 5 müxtəlif yerdə sorğu göndərilib hansı ki
       bunlardan 2-də User-lə yanaşı Role-lara da ehtiyac var. Biz entity class-in özündə fetch-type-i dəyişib eager etsək, bu 5 sorğunun hər birində user cədvəli ilə
       yanaşı role cədvəlinə də sorğu gedəcək, ki, bu da performans problemlərinə (N+1) səbəb olduğu üçün bizə sərf etmir. Ona görə də biz burada entity graph-dan istifadə edərək
       hansı sorğu da ki User-lə birlikdə də Role-a ehtiyac varsa bu zaman hər iki cədvələ sorğu getməsini təmin edirik.

       Nümunə :
       EntityGraph<User> entityGraph = entityManager.createEntityGraph(User.class);
       entityGraph.addAttributeNodes("roles");

       Map<String, Object> properties = new HashMap<>();
       properties.put("javax.persistence.loadgraph", entityGraph);

       User user = entityManager.find(User.class, userId, properties);

       loadGraph-Lazy
       fetchgraph-Eager

Question -5. Pessimistic vs Optimistic locking
            Optimistic və Pessimistic Locking Hibernate və JPA-də concurrency (eyni vaxtda birdən çox istifadəçinin məlumatlarla işləməsi) məsələlərini həll etmək üçün istifadə olunan iki fərqli yanaşmadır.
    1) Pessimistic locking ---> üzərində əməliyyat gedən entity locklanır ki, başqa bir user onun üzərində əməliyyat apara bilməsin.
                                BU prosses session səviyyəsində aparılır və transaction başlarkən açılan session sonlanana qədər və ya rolback
                                edilənə qədər row lock vəziyyətində qalır.(Qeyd: DeadLock-a səbəb ola bilər)
                                Hibernate-də Pessimistic Locking növlərini LockModeType vasitəsilə təyin edə bilərsiniz.
                                Hibernate-də əsas 3 növ Pessimistic Locking mövcuddur:
                                a) PESSIMISTIC_READ : locklanan row üzərində ancaq read əməliyyatı aparmaq mümkündür. Write əməliyyatına icazə verilmir.
                                b) PESSIMISTIC_WRITE : locklanan  row üzərində nə read, nə də write əməliyyatını aparmağa icazə verilmir.
                                                        Employee employee = entityManager.find(Employee.class, id, LockModeType.PESSIMISTIC_WRITE);
                                c) PESSIMISTIC_FORCE_INCREMENT : PESSIMISTIC_WRITE ilə eynidir, ondan fərqi ondadır ki, versiyalama prinsipi ilə işləyir.
                                                                 Row-a lock tədbiq edildikdə, həmin row üzərində dəyişiklik aparılmasa belə versiya nömrəsi artırılır.
                                                                 entityManager
                                                                     .lock(entity, LockModeType.PESSIMISTIC_FORCE_INCREMENT);

       Pessimistic lock Stock Management, Bank operations, Rental Services kimi case-lərdə tədbiq oluna bilər.
        I. Online alış-veriş saytında müştərilər eyni zamanda bir məhsulu sifariş edə bilərlər. Əgər bu məhsulun yalnız 1 ədəd qalığı varsa və iki müştəri eyni anda
           bu məhsulu sifariş etməyə çalışarsa, məhsul iki dəfə satıla bilər ki, bu da problemlər yarada bilər.
       -- Birinci müştəri məhsulu sifariş etmək istədikdə məhsulun stok məlumatı locklayır və başqa bir müştəri stok məlumatına müraciət edə bilmir.
       -- Əgər birinci müştəri məhsulu uğurla sifariş edərsə, stok yenilənir və kilid açılır.
       -- Sonra ikinci müştəri həmin məhsula müraciət etdikdə, artıq stokda mövcud olmadığını görür.

       II. Avtomobil icarəsi sistemində eyni avtomobili birdən çox istifadəçi eyni vaxtda rezerv etməyə çalışa bilər. Əgər bir avtomobil eyni anda bir neçə şəxsə icarəyə verilərsə,
           bu konflikt və narazılıq yarada bilər.
       -- İcarə sistemində, bir avtomobilin icarə üçün mövcudluğunu yoxlayarkən, həmin avtomobil kilidlənir.
       -- Avtomobilə həmin anda başqa bir şəxs müraciət etdikdə, onun kilidli olduğunu görür və mövcud olmadığını anlayır.
       -- İlk şəxs icarə prosesini tamamladıqdan sonra kilid açılır və başqa istifadəçilər bu avtomobili icarəyə götürə bilərlər.


       QEYD : pessimistic locking performansa mənfi təsir edə bilər, çünki obyektlər kilidləndikdə digər tranzaksiyalar gözləməli olur. Bu səbəbdən, bu metod yalnız ciddi məlumat təhlükəsizliyi və tamlığı tələb edən hallarda tətbiq olunmalıdır.

    2) Optimistic locking ---> bir row üzərində eyni anda birdən çox əməliyyatın gedə bildiyini göstərir və prosses zamanı heç bir lock-lama tədbiq olunmur.
                               Optimistic locking versiyalama prinspindən istifadə edir.
       @Version --> entity class-ında versiyalanma üçün yaradılan field-in üzərinə qoyulur. Adətən tam ədəd tipi və ya Date tipləri ilə istifadə olunur.
               -- Hibernate row-u çəkib oxuyarkən versiyanı da oxuyur və yadında saxlayır.
               -- Row üzərində dəyişiklik baş verən zaman, hibernate row-un versiya nömrəsini yenidən yoxlayır. Əgər bu zaman hibernate-in yaddaşda saxladığı
                  nömrə ilə bu nömrə uyğun gəlməzsə bu zaman conflict yaranır və OptimisticLockExaption atılır. Yox əgər hər iki versiya nömrəsi bir-birinə
                  eyni olarsa bu zaman əməliyyat uğurla aparılır və versiya nömrəsi 1 vahid artırılır.




Question -6. @Inheritance annotasiyası:
             Hibernate-də obyektlər arası əlaqəni qurur və bu obyektlərin verilənlər bazasında necə saxlanacağını təyin edir.
             Inheritance əlaqələri bir neçə strategiya ilə qurula bilər:
             a) SINGLE_TABLE
             b) JOINED
             c) TABLE_PER_CLASS

             -- SINGLE_TABLE : bütün əlaqəli siniflər üçün 1 cədvəl yaradılır, bütün field-lər bir cədvəldə saxlanılır.
                               Fərqli sinif field-lərini bir-birindən ayırmaq üçün discriminator column istifadə olunur:

                               @Entity
                               @Inheritance(strategy = InheritanceType.SINGLE_TABLE)
                               @DiscriminatorColumn(name = "vehicle_type", discriminatorType = DiscriminatorType.STRING)
                               public class Vehicle {
                                   @Id
                                   private Long id;
                                   private String model;
                               }

                               @Entity
                               @DiscriminatorValue("Car")
                               public class Car extends Vehicle {
                                   private int numberOfDoors;
                               }

                               @Entity
                               @DiscriminatorValue("Bike")
                               public class Bike extends Vehicle {
                                   private boolean hasPedals;
                               }

                             SQL-də qarşılığı:

                             CREATE TABLE Vehicle (
                                 id BIGINT NOT NULL,
                                 model VARCHAR,
                                 numberOfDoors INTEGER,
                                 hasPedals BOOLEAN,
                                 vehicle_type VARCHAR(255),
                                 PRIMARY KEY (id)
                             );

             -- JOINED : Super class bir cədvəldə, subclass-lar isə hər biri ayrı cədvəldə saxlanılır.
                         Bu cədvəllərin birləşdirilməsində join operatoru istifadə olunur deyə adı da ordan gəlir:

                         CREATE TABLE Vehicle (
                             id BIGINT NOT NULL,
                             model VARCHAR,
                             PRIMARY KEY (id)
                         );

                         CREATE TABLE Car (
                             id BIGINT NOT NULL,
                             numberOfDoors INTEGER,
                             PRIMARY KEY (id),
                             FOREIGN KEY (id) REFERENCES Vehicle (id)
                         );

                        SQL qarşılığı :

                         CREATE TABLE Bike (
                             id BIGINT NOT NULL,
                             hasPedals BOOLEAN,
                             PRIMARY KEY (id),
                             FOREIGN KEY (id) REFERENCES Vehicle (id)
                         );

             -- TABLE_PER_CLASS : Bu strategiyada hər subclass (alt sinif) öz məlumatlarını saxlayan ayrıca cədvəl yaradır.
                                  Hər bir subclass cədvəlində superclass-a aid olan sahələr təkrarlanır.
                                  Bank sistemini nəzərdən keçirək, burada Account adlı bir superclass
                                  (əsas sinif) var və onun iki subclass-ı (alt sinifi) SavingsAccount və CheckingAccount var.

                                  @Entity
                                  @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
                                  public abstract class Account {
                                      @Id
                                      @GeneratedValue(strategy = GenerationType.AUTO)
                                      private Long id;
                                      private String accountHolder;
                                      private double balance;

                                      // Getters and setters
                                  }

                                  @Entity
                                    public class SavingsAccount extends Account {
                                        private double interestRate;

                                        // Getters and setters
                                    }
                                  @Entity
                                  public class CheckingAccount extends Account {
                                      private double overdraftLimit;

                                      // Getters and setters
                                  }

                                  SQL qarşılığı :

                                  CREATE TABLE Account (
                                      id BIGINT NOT NULL,
                                      accountHolder VARCHAR,
                                      balance DOUBLE,
                                      PRIMARY KEY (id)
                                  );
                                  CREATE TABLE SavingsAccount (
                                      id BIGINT NOT NULL,
                                      accountHolder VARCHAR,
                                      balance DOUBLE,
                                      interestRate DOUBLE,
                                      PRIMARY KEY (id)
                                  );
                                  CREATE TABLE CheckingAccount (
                                      id BIGINT NOT NULL,
                                      accountHolder VARCHAR,
                                      balance DOUBLE,
                                      overdraftLimit DOUBLE,
                                      PRIMARY KEY (id)
                                  );



Question -7. @Primary annotasiyası:
           @Autowired ilə avtomatik daxil etmə (autowiring) zamanı Spring-in hansı bean-i seçəcəyini müəyyən edir.
           Bu, eyni tipdə birdən çox bean olduğu halda hansı bean-in default olaraq istifadə olunacağını göstərir.

Question -8. @Qualifier annotasiyası:
             Spring containerdə birdən çox eyni tipdə bean olduqda, hansı bean-in injectə olacağını təyin edən annotasiyadır.
             Bean-lər təyin olunan zaman (@Component, @Service) onlara id təyin olunur. Məsələn:
             @Service("test")
             Inject zamanı hansı bean istifadə olunmalıdırsa qualifier annotasiyasi vasitəsilə həmin bean-in id-i göstərilir. Məsələn:
             @Autowired
             public Payment(@Qualifier("test") PaymentService service)
                 {
                    this.service=service;
                 }

             Qeyd: @Qualifier @Primary-dən daha çox üstünlük dərəcəsinə malikdir, yəni, @Qualifer olan yerdə @Primary nəzərə alınmır.


Question -9. @Transactional nə üçün istifadə olunur?
             SQL-dəki tranzaksiya ilə eyni prinsipdə işləyir. Bu annotasiya ilə təyin olunan metodların daxilindəki bütün əməliyyatlar atomik olaraq icra olunur.
             Yəni fərz edək ki, metod daxilində 3 əməliyyat var. Əgər bu əməliyyatlardan hər hansı birində uğursuzluq baş verərsə digər əməliyyatlar da geri alınacaq (rollback).
             Real Case Scenario:
             a) Banking System: Bank əməliyyatları zamanı pul köçürməsi kimi əməliyyatlar həyata keçirilir. Əgər pul göndərmə əməliyyatında səhv olarsa, pul köçürülməsi əməliyyatı tamamilə geri qaytarılmalıdır.
             b) E-commerce System: Müştəri ödəniş etdikdən sonra sifariş məlumatları bazaya yazılır. Ödəniş prosesi uğursuz olarsa, sifariş məlumatlarının da yazılmaması üçün rollback təmin edilir.
             Bəzi hallarda metodun @Transactional annotasiyası ilə təyin olunmasına baxmayaraq tranzaksiya məntiqi işləməyə bilər. Bu hansı halda ola bilər?

             1. Metodun eyni sinif içində çağırılması (Self-invocation):

                     Bu problemi başa düşmək üçün ilk öncə @Transactional-ın işləmə məntiqini başa düşək:
                     @Transactional annotasiyası tranzaksiyanı proxy mexanizmi ilə idarə edir.
                     Spring Proxy mexanizmi nədir?
                     Spring @Transactional annotasiyasını əlavə etdiyiniz zaman, bu metod bir proxy obyekt vasitəsilə idarə olunur. Proxy, orijinal metodun ətrafında bir “qat” yaradaraq metodun çağırılmasını idarə edir.
                     @Transactional annotasiyası ilə proxy mexanizmi, tranzaksiya başlamadan əvvəl və tranzaksiya başa çatdıqdan sonra müəyyən məntiqi işə salmaq üçün istifadə olunur.

                     Proxy mexanizmi Spring-in Aspect-Oriented Programming (AOP) infrastrukturunun bir hissəsidir. @Transactional annotasiyası əlavə etdiyiniz zaman,
                     Spring həmin sinfi və metodları proxy sinif kimi yaradır. Yəni, real sinif deyil, həmin sinfin bir “surəti” proxy olaraq yaradılır. Bu proxy sinif metodları çağıranda tranzaksiya məntiqini işə salır.

                     Proxy obyektin tranzaksiya idarəetməsi aşağıdakı mərhələlərdə baş verir:

                     -- Metod çağırılır.
                     -- Proxy obyekt tranzaksiya başlayır.
                     -- Əsas metod icra edilir.
                     -- Əgər istisna baş verməzsə, tranzaksiya commit olunur (yəni uğurla başa çatdırılır).
                     -- Əgər istisna baş verərsə, tranzaksiya rollback olunur (yəni geri qaytarılır).

                     Self-invocation problemi nədir?

                     Self-Invocation Problemi: Eyni class daxilində bir metod digər bir metodu çağırdıqda, bu çağırış birbaşa həmin sinifin instance-ı vasitəsilə edilir.
                     Nəticədə, tranzaksiya proxy sinifin əvəzinə, orijinal metod çağırılır və tranzaksiya məntiqi işə düşmür.
                     Proxy obyektinin yarana bilməməsi səbəbi nədir?
                     Proxy obyektin yaranmaması problemi əslində yarana bilməmək deyil, proxy obyektin daxili çağırışları idarə etməməsidir. Yəni, proxy obyekt sinif xaricindən edilən çağırışları idarə edir,
                     ancaq sinfin öz daxilindəki çağırışlarda işə düşmür.

                     Bu problemin həlli üçün :
                     -- Başqa sinifdən çağırış.
                     -- AspectJ proxy istifadə.
                     -- Manuel tranzaksiya idarəçiliyi (TransactionTemplate).
                     -- AopContext.currentProxy() metodu ilə proxy obyektini istifadə.
                     -- Metodları fərqli siniflərə bölmək.

             2. Metodun private və ya final olması:
                         Spring AOP (Aspect-Oriented Programming) mexanizmi yalnız public metodlarda işləyir. Əgər metod private və ya final təyin edilibsə,
                         tranzaksiya məntiqi tətbiq olunmur, çünki Spring bu metodlara proxy tətbiq edə bilmir.

             3.Exception-ların düzgün idarə olunmaması:
                         Default olaraq, Spring yalnız unchecked exceptions (runtime exceptions) baş verdikdə tranzaksiyanı geri qaytarır (rollback edir). Əgər checked exceptions atılırsa, Spring həmin tranzaksiyanı rollback etmir.
                         Bu da tranzaksiya məntiqinin düzgün işləməməsinə səbəb ola bilər.

Question -10. Isolation levels :
              Bir tranzaksiyanın digər tranzaksiyaya təsir səviyyəsini müəyyən edir.
              Düzgün istifadəsi "dirty reads", "non-repeatable reads" və "phantom reads" kimi problemləri idarə etmək olur.
              İzolyasiya səviyyələri tranzaksiya ACID prinsiplərinin bir hissəsidir (Atomicity, Consistency, Isolation, Durability).

              Dirty read: Bir tranzaksiya digər tranzaksiyanın hələ təsdiqlənməmiş məlumatlarını oxuya bilər.
                          Məsələn, əgər həmin tranzaksiya sonradan geri çəkilsə (rollback), artıq yanlış məlumat oxunmuş olur.
              Non-Repeatable Read : Bir tranzaksiyanın eyni sətri 2-ci dəfə oxuduğu zaman, ilk oxuğuduğu məlumatdan fərqli məlumat alması problemidir.
                                    Bunun səbəbi o olur ki, bu tranzaksiya ilk dəfə sətri oxuyur, sonra başqa bir tranzaksiya bu sətir üzərində hər hansı
                                    bir əməliyyat icra etdiyi üçün ilk tranzaksiya bura 2-ci dəfə gəldikdə fərqli məlumatla qarşılaşır.
              Phantom read: bu problem, bir tranzaksiya daxilində bir SELECT sorğusunun icrası zamanı, eyni tranzaksiyanın daha sonra eyni SELECT sorğusunu
                            icra etdikdə fərqli nəticələr əldə etməsi ilə yaranır. Bu, verilənlər bazasında başqaları tərəfindən əlavə edilən və ya silinən
                            məlumatların tranzaksiya icra edildiyi vaxtda vəziyyəti dəyişdirməsi nəticəsində baş verir.

                         --> Non-Repeatable Read  vs  Phantom read

                            Non-Repeatable Read --> eyni sətir üzərindəki dəyişiklikdən gedir söhbət. Məsələn:
                            Select Name from Person where id=1 --> bu sorgudan Gulshan qayidir
                            Əgər başqa bir tranzaksiya bu sətir üzərində update əməliyyatı apararsa:
                            Update Person set Name="Gülşən"
                            Bu zaman birinci tranzaksiya ikinci dəfə bu sətri oxuduqda:
                            Select Name from Person where id=1 --> bu sorgudan Gülşən qayidir

                            Phantom read --> Bu problem isə adətən Select sorğuların nəticələrinin fərqli gəlməsi zamanı yaranır. Məsələn:
                            Select * from Person ---> Tranzaksiya A (ilk cəhd)  --> output : 5 rows
                            Insert... ---> Tranzaksiya B (Yeni row-lar əlavə olundu)
                            Select * from Person ---> Tranzaksiya A (ikinci cəhd)  --> output : 8 rows

                            Tranzaksiya A-nın ilk və ikinci cəhdlərində output-lar eyni olmadığı üçün  Phantom read problemi yaranır.

               Hansı isolation level-lər var?
                a) READ UNCOMMITTED
                b) READ COMMITTED
                c) REPEATABLE READ
                d) SERIALIZABLE

              İzolyasiya Səviyyəsi     | Dirty read  |  Non-Repeatable Read | Phantom read | Məlumatın Təkrarlanması
            --------------------------------------------------------------------------------------------------------------
              READ UNCOMMITTED         | true        |  true                | true         | Minimum izolyasiya
              READ COMMITTED           | false       |  true                | true         | Orta səviyyədə izolyasiya
              REPEATABLE READ          | true        |  false               | true         | Yüksək izolyasiya
              SERIALIZABLE             | false       |  false               | false        | Tam izolyasiya


              a) READ UNCOMMITTED : Bu ən aşağı izolyasiya səviyyəsidir. Bir tranzaksiya başqalarının təsdiqlənməmiş (uncommitted) məlumatlarını oxuya bilər.
              b) READ COMMITTED : Bu səviyyədə bir tranzaksiya yalnız digər tranzaksiyalar tərəfindən təsdiqlənmiş (committed) məlumatları oxuya bilər.
                                  Bu, dirty read problemini həll edir.
              c) REPEATABLE READ : Bu səviyyə, tranzaksiya daxilində məlumatın sabit qalmasını təmin edir. Bir tranzaksiya eyni məlumatı bir neçə dəfə oxuyarsa,
                                   o məlumatın digər tranzaksiya tərəfindən dəyişdirilməsinə icazə verilmir.
              d) SERIALIZABLE  : Bu ən yüksək izolyasiya səviyyəsidir. Tranzaksiyalar bir-birinin tamamilə təcrid olunmuş şəkildə işləməsini təmin edir.
                                 Eyni vaxtda birdən çox tranzaksiya işlədilə bilməz və hər bir tranzaksiya sıralı şəkildə icra olunur.

 Qeydlər :
     |__ @Transactional annotasiyası class səviyyəsində istifadə olunarsa bu zaman bu class-ın daxilində olan bütün public metodlara tədbiq olunacaq;
     |__ @Transactional metod səviyyəsinə təyin olunarsa bu metod ancaq public olmalıdır. Çünki proxy obyketi yalnız xaricdə çağrılma zamanı doğru işləyir.

